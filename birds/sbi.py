from sbi.inference import prepare_for_sbi, SNPE, SNLE

def sbi_training(simulator,
				 prior,
				 y,
				 method,
				 density_estimator="maf",
				 n_samples=10_000,
				 n_sims=[10_000], 
				 sim_postprocess=lambda x: x,
				 num_workers=15,
				 outloc=None):

    """
    Required inputs:

    - simulator:        callable, consumes torch.tensor containing the input
                        parameters for the model and returns SUMMARY STATISTICS
                        generated by the model. TODO: extend so that we can use
                        embedding networks, although perhapt not possible or
                        necessary for the methods we compare against in this
                        paper.
    - prior:            must have .log_prob and .sample methods. Just use a
                        torch distribution
    - y:                torch.tensor containing observed SUMMARY STATISTICS of 
                        the observed data
    - method:           str, must be in ["SNPE", "SNLE", "SNVI"]

    Optional:
    - density_estimator: can be a string naming one of the density estimators
                         already implemented in sbi, or another custom density
                         estimator
    - n_samples:         int, number of final samples to get from the final 
                         posterior
    - n_sims:            list of ints. Each int in the list specifies number of
                         simulations to generate at each training round.
                         Amortised inference corresponds to list of length 1
    - sim_postprocess:   callable, transforms output of simulator. NOT IMPLEMENTED
    - num_workers:       NOT YET IMPLEMENTED
    - outloc:            str, location to save data. If None, samples aren't saved
    """

	sbi_simulator, sbi_prior = prepare_for_sbi(simulator, prior)
	posteriors = []
	proposal = sbi_prior

	if method == "SNPE":
		inference = SNPE(prior=sbi_prior, density_estimator=density_estimator)
	elif method == "SNLE":
		inference = SNLE(prior=sbi_prior, density_estimator=density_estimator)
    elif method == "SNVI":
        inference = SNLE(prior=sbi_prior, density_estimator=density_estimator)

    for sim_count in n_sims:
        theta = proposal.sample((sim_count,))
        x = sbi_simulator(theta)
		# This is usually for reshaping for the embedding net
		#x = sim_postprocess(x)
        if method == "SNPE":
            _ = inference.append_simulations(theta, x, proposal=proposal).train()
        else:
            _ = inference.append_simulations(theta, x).train()
        if method == "SNPE":
            posterior = inference.build_posterior().set_default_x(y)
        elif method == "SNLE":
            posterior = inference.build_posterior().set_default_x(y)
        elif method == "SNVI":
            posterior = inference.build_posterior(sample_with="vi", vi_method="fKL").set_default_x(y)
		posteriors.append(posterior)
        proposal = posterior

    samples = proposal.sample((n_samples,))

	if not outloc is None:
        torch.save(samples, outloc)

    return samples
